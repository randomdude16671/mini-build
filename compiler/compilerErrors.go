/*
This file contains some errors and stuff to help the self explorability of the software, Errors contained in this file:
  - InputMissingError:
    when one of the inputs to a task is missing
  - OutputMissingError:
    when one of the outputs of a task is not generated by itself.

NOTE: Make sure to document the rest when adding new ones
*/
package compiler

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func getLineFromFile(path string, lineNo int) (string, error) {
	var out strings.Builder
	file, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	current := 1
	for scanner.Scan() {
		if current >= lineNo-1 && current <= lineNo+1 {
			prefix := "   "
			if current == lineNo {
				prefix = " > "
			}
			out.WriteString(fmt.Sprintf("%s%d | %s\n", prefix, current, scanner.Text()))
		}
		if current > lineNo+1 {
			break
		}
		current++
	}

	if err := scanner.Err(); err != nil {
		return "", err
	}

	return out.String(), nil
}

type InputMissingError struct {
	File         string
	NotFoundFile string
	Op           string
	Err          error

	Line int
	Col  int
}

func (im *InputMissingError) Error() string {
	return fmt.Sprintf("%s: %v", im.Op, im.Err)
}

// Human returns a multiline diagnostic like a compiler error
func (im *InputMissingError) Human() string {
	var out strings.Builder
	out.WriteString("\n")
	out.WriteString("error: input file not found\n")
	out.WriteString(fmt.Sprintf("  → %s:%d:%d\n", im.File, im.Line, im.Col))

	lines, err := getLineFromFile(im.File, im.Line)
	if err == nil {
		out.WriteString(lines)
		// Add a caret under the column position
		out.WriteString("     ")
		for i := 1; i < im.Col; i++ {
			out.WriteByte(' ')
		}
		out.WriteString("^\n")
	}

	out.WriteString(fmt.Sprintf("\nnote: the file %q is required but was not found.\n", im.NotFoundFile))
	return out.String()
}

// When output is not generated from given task
type OutputMissingError struct {
	File         string
	NotFoundFile string
	Op           string
	Err          error

	Line int
	Col  int
}

func (ome *OutputMissingError) Error() string {
	return fmt.Sprintf("%s: %v", ome.Op, ome.Err)
}

func (ome *OutputMissingError) Human() string {
	var out strings.Builder
	out.WriteString("\n")
	out.WriteString("error: output file not generated\n")
	out.WriteString(fmt.Sprintf("  → %s:%d:%d\n", ome.File, ome.Line, ome.Col))

	lines, err := getLineFromFile(ome.File, ome.Line)
	if err == nil {
		out.WriteString(lines)
		// Add a caret under the column position
		out.WriteString("     ")
		for i := 1; i < ome.Col; i++ {
			out.WriteByte(' ')
		}
		out.WriteString("^\n")
	}

	out.WriteString(fmt.Sprintf("\nnote: the file %q is required but was not generated.\n", ome.NotFoundFile))
	return out.String()
}

type SyntaxError struct {
	ExpectedToken string
	GivenToken    string
	Line          int
	Col           int
	File          string
}

func (se *SyntaxError) Error() string {
	return fmt.Sprintf("syntax error: expected %s, got %s", se.ExpectedToken, se.GivenToken)
}

func (se *SyntaxError) Human() string {
	var out strings.Builder
	out.WriteString("\n")
	out.WriteString(fmt.Sprintf("syntax error: expected %s, got %s", se.ExpectedToken, se.GivenToken))
	out.WriteString(fmt.Sprintf("  → %s:%d:%d\n", se.File, se.Line, se.Col))

	lines, err := getLineFromFile(se.File, se.Line)
	if err == nil {
		out.WriteString(lines)
		// Add a caret under the column position
		out.WriteString("     ")
		for i := 1; i < se.Col; i++ {
			out.WriteByte(' ')
		}
		out.WriteString("^\n")
	}
	out.WriteString("\n")

	return out.String()
}
