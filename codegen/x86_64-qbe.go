package codegen

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"

	l "github.com/randomdude16671/mini-build/language"
)

type QBE_GenerationEnv struct {
	evalMode l.EvalMode            // the evaluation mode to compile to
	tasks    map[string]*l.TaskDef // { "name": TaskDef }
	Program  l.Program             // Program to parse  and compile into IR
}

type QBE_Generator struct {
	output       *strings.Builder
	file         string
	currentLabel string
	env          *QBE_GenerationEnv // Env for runtime values
}

func New_QBE_Generator(outputBuilder *strings.Builder, file string) *QBE_Generator {
	filepathAbs, err := filepath.Abs(file)
	if err != nil {
		fmt.Printf("Error: %v\n", err)
		return nil
	}
	return &QBE_Generator{
		output: outputBuilder,
		file:   filepathAbs,
	}
}

// Function to add the important comments to the strings builder into the output
func (q *QBE_Generator) AddComments() error {
	if q.output.String() != "" {
		return errors.New("the builder has to be empty to add the comments")
	}
	q.output.WriteString("# Generated by mini-build")

	// This is just in case the user generates and opens the IR file
	q.output.WriteString("# THIS FILE IS NOT INTENDED FOR EDITING, THIS IS THE IR OUTPUT OF `mini-build`'s COMPILATION.")
	return nil
}

func (q *QBE_Generator) RegisterTask(task *l.TaskDef) {
	q.env.tasks[task.Name] = task
}

func (q *QBE_Generator) ParseProgram() {
	for _, stmt := range q.env.Program.Statements {
		if stmt.Type() == l.TaskDefNode {
			task := stmt.(*l.TaskDef)
			q.RegisterTask(task)
		}
	}
}
